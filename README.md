# Mac下Android Studio集成OpenCV示例


感谢 **Android弟** 的Blog帮助我在Windows下成功集成OpenCV  [链接地址](http://blog.csdn.net/sbsujjbcy/article/details/49520791)


#安装软件, 依次按照顺序下载安装
1. 下载安装JDK1.8, 下载地址: http://download.oracle.com/otn-pub/java/jdk/8u73-b02/jdk-8u73-macosx-x64.dmg
2. 下载Android SDK, 下载地址: http://dl.google.com/android/android-sdk_r24.4.1-macosx.zip
3. 下载Android NDK, 下载地址: http://dl.google.com/android/repository/android-ndk-r11-darwin-x86_64.zip
4. 下载安装Android Studio 1.5.1, 下载地址: https://dl.google.com/dl/android/studio/install/1.5.1.0/android-studio-ide-141.2456560-mac.dmg
5. 下载OpenCV for Android, 下载地址: http://120.52.72.56/jaist.dl.sourceforge.net/c3pr90ntcsf0/project/opencvlibrary/opencv-android/3.1.0/OpenCV-3.1.0-android-sdk.zip

> **注意：**
> 在当前用户目录下创建Library/Android, 然后把Android SDK解压到创建的目录下,修改目录名称为sdk, 然后把Android NDK解压到sdk根目录下. 如果当前用户目录的路径有特殊字符、空格或者数字，请切换到其他目录下，保证目录路径没有特殊字符、空格或者数字
>如无法直接下载上面的连接, 可使用迅雷. 若还无法下载, 你懂得, 那只能翻墙了
>安装好Android Studio之后, 配置SDK路径. 目前用的SDK是6.0

#准备好开发环境, 正式开始
######1. 打开Android Studio, 新建工程My Application, 包名定义成:com.jack.opencv（AS包名是反着来的，所以输入的时候是: opencv.jack.com)
######2. 点击下一步，选择Minimum SDK为4.0.3 (基本上支持4.0.3可以兼容市面上97.3%的机器了,剩下的都是一些古董级手机)
######3. 继续下一步, 选择一个Empty Activity, 然后下一步, 最后直接Finish. (Finish完之后, 如果是第一次运行AS, 需要等待一段时间, 因为需要下载Gradle依赖的包, Gradle跟Maven类似, 有Maven经验的, 很容易就上手Gradle了)
######4. Gradle下载完毕后, 会打开AS主界面了. 点击最左边的Tab选项, 选中Project选项卡, 会出现App项目,  可以看到上面显示Android字样, 表示是Android视图, 点击可以切换成Project视图模式.
######5. 选中MyApplication, 右键创建native文件夹(native文件夹和app文件夹是同一层目录)
######6. 解压之前下载的OpenCV for Android, 解压后在sdk目录下有一个native, native下有三个文件夹, 3rdparty, jni和libs, 把这三个目录复制到刚才在MyApplication里创建的native目录下
######7. 打开gradle.properties,增加下面的属性使用旧版的ndk功能(不添加会使用实验性的ndk构建工具)
```text
android.useDeprecatedNdk=true
```
######8. 解压下载的Android NDK到Android SDK根目录下, 并修改文加名为ndk
######9. 回到AS, 打开local.properties, 配置ndk目录:
```text 
ndk.dir=/Users/jack/Library/Android/sdk/ndk
```
######10. 在App项目下的src/main下创建jni目录(右键New时，选择Folder → JNI Folder创建)
######11. 在jni根目录下, 创建2个文件. Android.mk和Application.mk
######12. 打开Application.mk, 新增
```text
APP_STL := gnustl_static
APP_CPPFLAGS := -frtti -fexceptions
APP_ABI := armeabi armeabi-v7a
APP_PLATFORM := android-8
```
######13. 打开Android.mk, 新增
```text
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
OpenCV_INSTALL_MODULES := on
OpenCV_CAMERA_MODULES := off
OPENCV_LIB_TYPE :=STATIC
ifeq ("$(wildcard $(OPENCV_MK_PATH))","")
include ../../../../native/jni/OpenCV.mk
else
include $(OPENCV_MK_PATH)
endif
LOCAL_MODULE := OpenCV
LOCAL_SRC_FILES :=
LOCAL_LDLIBS +=  -lm -llog
include $(BUILD_SHARED_LIBRARY)
```
######14. 打开build.gradle, 在android节点中增加下面的代码
```text
//禁止自带的ndk功能
sourceSets.main.jni.srcDirs = []
//重定向so目录为src/main/libs和src/main/jniLibs，原来为src/main/jniLibs
sourceSets.main.jniLibs.srcDirs = ['src/main/libs','src/main/jniLibs']
task ndkBuild(type: Exec, description: 'Compile JNI source with NDK') {
    Properties properties = new Properties()
    properties.load(project.rootProject.file('local.properties').newDataInputStream())
    def ndkDir = properties.getProperty('ndk.dir')
    if (org.apache.tools.ant.taskdefs.condition.Os.isFamily(org.apache.tools.ant.taskdefs.condition.Os.FAMILY_WINDOWS)) {
        commandLine "$ndkDir/ndk-build.cmd", '-C', file('src/main/jni').absolutePath
    } else {
        commandLine "$ndkDir/ndk-build", '-C', file('src/main/jni').absolutePath
    }
}
tasks.withType(JavaCompile) {
    compileTask -> compileTask.dependsOn ndkBuild
}
task ndkClean(type: Exec, description: 'Clean NDK Binaries') {
    Properties properties = new Properties()
    properties.load(project.rootProject.file('local.properties').newDataInputStream())
    def ndkDir = properties.getProperty('ndk.dir')
    if (org.apache.tools.ant.taskdefs.condition.Os.isFamily(org.apache.tools.ant.taskdefs.condition.Os.FAMILY_WINDOWS)) {
        commandLine "$ndkDir/ndk-build.cmd",'clean', '-C', file('src/main/jni').absolutePath
    } else {
        commandLine "$ndkDir/ndk-build",'clean', '-C', file('src/main/jni').absolutePath
    }
}
clean.dependsOn 'ndkClean'
```
######15. build项目, 如果能成功在src/main/libs下构建出so, 说明配置没问题
######16. 声明java层的native方法
```java
package com.jack.opencv.myapplication;
public class OpenCVHelper {
    static{
        System.loadLibrary("OpenCV");
    }
    public static native int[] gray(int[] buf, int w, int h);
}
```
######17. 使用javah命令生成头文件，成功生成的内容如下(打开终端, 进入app项目java代码包的根目录下执行: javah -classpath . com.jack.opencv.myapplication.OpenCVHelper)
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jack_opencv_myapplication_OpenCVHelper */

#ifndef _Included_com_jack_opencv_myapplication_OpenCVHelper
#define _Included_com_jack_opencv_myapplication_OpenCVHelper
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_jack_opencv_myapplication_OpenCVHelper
 * Method:    gray
 * Signature: ([III)[I
 */
JNIEXPORT jintArray JNICALL Java_com_jack_opencv_myapplication_OpenCVHelper_gray
  (JNIEnv *, jclass, jintArray, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
```
######18. 移动生成的头文件到jni目录下, 并编写对应的实现逻辑cpp代码(可以直接复制下面的逻辑, 注意修改包路径)
```c
#include "com_jack_opencv_myapplication_OpenCVHelper.h"
#include <stdio.h>
#include <stdlib.h>
#include <opencv2/opencv.hpp>

using namespace cv;

extern "C" {

JNIEXPORT jintArray JNICALL Java_com_jack_opencv_myapplication_OpenCVHelper_gray(
        JNIEnv *env, jclass obj, jintArray buf, int w, int h);



JNIEXPORT jintArray JNICALL Java_com_jack_opencv_myapplication_OpenCVHelper_gray(
        JNIEnv *env, jclass obj, jintArray buf, int w, int h) {

    jint *cbuf;
    cbuf = env->GetIntArrayElements(buf, JNI_FALSE );
    if (cbuf == NULL) {
        return 0;
    }

    Mat imgData(h, w, CV_8UC4, (unsigned char *) cbuf);

    uchar* ptr = imgData.ptr(0);
    for(int i = 0; i < w*h; i ++){
        //计算公式：Y(亮度) = 0.299*R + 0.587*G + 0.114*B
        //对于一个int四字节，其彩色值存储方式为：BGRA
        int grayScale = (int)(ptr[4*i+2]*0.299 + ptr[4*i+1]*0.587 + ptr[4*i+0]*0.114);
        ptr[4*i+1] = grayScale;
        ptr[4*i+2] = grayScale;
        ptr[4*i+0] = grayScale;
    }

    int size = w * h;
    jintArray result = env->NewIntArray(size);
    env->SetIntArrayRegion(result, 0, size, cbuf);
    env->ReleaseIntArrayElements(buf, cbuf, 0);
    return result;
}
}
```
######19. 之后，需要将cpp文件编译进去，在Andorid.mk文件中加入
```text
LOCAL_SRC_FILES := com_jack_opencv_myapplication_OpenCVHelper.cpp
```
######20. 到这一步，就是见证奇迹的时刻到了. 刚才写的实现, 是把一个图片颜色变灰. 我们可以在MainActivity里面编辑代码：
```java
package com.jack.opencv.myapplication;

import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.media.Image;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.ImageView;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        final ImageView imageView = (ImageView) findViewById(R.id.imageView);
        imageView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Bitmap bitmap = ((BitmapDrawable) getResources().getDrawable(
                        R.drawable.ic)).getBitmap();
                int w = bitmap.getWidth(), h = bitmap.getHeight();
                int[] pix = new int[w * h];
                bitmap.getPixels(pix, 0, w, 0, 0, w, h);
                int[] resultPixes = OpenCVHelper.gray(pix, w, h);
                Bitmap result = Bitmap.createBitmap(w, h, Bitmap.Config.RGB_565);
                result.setPixels(resultPixes, 0, w, 0, 0, w, h);
                imageView.setImageBitmap(result);
            }
        });
    }
}
```
######21. 在手机中运行App, 点击图片, 我们发现图片变灰了.  一切大功告成 

> **注意：**
>  这只是纯jni层实现方式, 后面还有其他实现方式, 大同小异, 有兴趣的可以参考Windows里面的实现方式
